#!/usr/bin/python
# <*******************
# 
# Copyright 2018 Juniper Networks, Inc. All rights reserved.
# Licensed under the Juniper Networks Script Software License (the "License").
# You may not use this script file except in compliance with the License, which is located at
# http://www.juniper.net/support/legal/scriptlicense/
# Unless required by applicable law or otherwise agreed to in writing by the parties, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# 
# *******************>
"""
    Wrapper script for all NITA commands
"""
import commands as commands
import sys
import os

def nested_keys(dictionary, path=None):
    """
    Function that returns all nested keys in a dictionary.
    """
    if path is None:
        path = []
    for k,v in dictionary.items():
        newpath = path + [k]
        if isinstance(v, dict):
            for u in nested_keys(v, newpath):
                yield u
        else:
            yield newpath, v

def print_nested_keys(dictionary):
    """
    Function that prints a set of all nested keys (from root to leaf) 
    in a dictionary with its correspondent value.
    """
    for root2leaf, value in nested_keys(dictionary):
        # Not print the license when in help
        if 'license' not in root2leaf:
            print '   ' + commands.KEY_SEPARATOR.join(root2leaf) + ' => ' + value

def print_command_with_keys(dictionary, keys):
    """
    Function that prints the command as a string containing all keys passed as a list from the dictionary.
    """
    for root2leaf, value in nested_keys(dictionary):
        command_keys = commands.KEY_SEPARATOR.join(root2leaf)
        match = { key in command_keys for key in keys }
        if match == set([True]):
            return command_keys

def cli2command(cli, translator):    
    for k in cli: 
        translator = translator[str(k)]
    return translator

def commands_vs_help_trees():
    """
    Function that checks if commands.COMMANDS & commands.HELP trees
    have the same nested keys (i.e. tries to avoid missing documentation
    and or a mapped value of a newly added command!).
    """

    finish = False
    commands_set = {frozenset(root2leaf) for root2leaf, value in nested_keys(commands.COMMANDS)}
    help_set =     {frozenset(root2leaf) for root2leaf, value in nested_keys(commands.HELP)}

    help_diff = commands_set - help_set
    help_missing = help_diff != set([])
    commands_diff = help_set - commands_set
    commands_missing = commands_diff != set([])

    if help_missing:
        
        command_keys_list = [list(command) for command in list(help_diff)]
        for item in command_keys_list:
            missing = print_command_with_keys(commands.COMMANDS, item)
            print ''
            print '     The following command: "' + missing + '" is missing its description!'
            finish = True
        print ''
        print ' >>> Please add it to the HELP tree!'
        print ''

    if commands_missing:
        
        command_keys_list = [list(command) for command in list(commands_diff)]
        for item in command_keys_list:
            missing = print_command_with_keys(commands.HELP, item)
            print ''
            print '     The following command: "' + missing + '" is missing its mapped command!'
            finish = True
        print ''
        print ' >>> Please add it to the COMMANDS tree!'
        print ''
    
    if finish:
        sys.exit()


def main():
    
    commands_vs_help_trees()
    # print 'Number of arguments:', len(sys.argv), 'arguments.'
    # print 'Argument List:', str(sys.argv)
    if 'help' in sys.argv:
        print ''
        print_nested_keys(commands.HELP)
        print ''
        sys.exit()

    # Remove /usr/local/bin/ from first argument (/usr/local/bin/nita)
    root = sys.argv[0].split('/')[-1]
    cli = sys.argv[1:]
    cli.insert(0, root)

    try:
        command = cli2command(cli, commands.COMMANDS)
        # If % vars in command
        if '%' in command:

            print ''
            print '  >>>> command: ', command % commands.PROJECT_PATH
            print ''
            os.system(command % commands.PROJECT_PATH)

        else:
            print ''
            print '  >>>> command: ', command
            print ''
            os.system(command)

    except KeyError as ke:
        print ''
        print('"' + ke.message + '" key does not exist at COMMANDS dictionary')
        print ''

if __name__ == '__main__':
    main()
