#!/usr/bin/python
# <*******************
# 
# Copyright 2018 Juniper Networks, Inc. All rights reserved.
# Licensed under the Juniper Networks Script Software License (the "License").
# You may not use this script file except in compliance with the License, which is located at
# http://www.juniper.net/support/legal/scriptlicense/
# Unless required by applicable law or otherwise agreed to in writing by the parties, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# 
# *******************>
"""
    Wrapper script for all NITA commands
"""
import commands as commands
import sys
import os

def nested_keys(dictionary, path=None):
    """
    Function that returns all nested keys in a dictionary.
    """
    if path is None:
        path = []
    for k,v in dictionary.items():
        newpath = path + [k]
        if isinstance(v, dict):
            for u in nested_keys(v, newpath):
                yield u
        else:
            yield newpath, v

def print_nested_keys(dictionary):
    """
    Function that prints a set of all nested keys (from root to leaf) 
    in a dictionary with its correspondent value.
    """
    for root2leaf, value in nested_keys(dictionary):
        # Not print the license when in help
        if 'license' not in root2leaf:
            print '   ' + commands.KEY_SEPARATOR.join(root2leaf) + ' => ' + value

def cli2command(cli, translator):    
    for k in cli: 
        translator = translator[str(k)]
    return translator

def commands_vs_help():
    """
    Function that checks if commands.COMMANDS & commands.HELP
    have the same nested keys (i.e. tries to avoid missing documentation
    of a newly added command!).
    """
    help_set = set([])
    commands_set = set([])

    # If adding below set, following error is shown:
    # TypeError: unhashable type: 'set'
    # set(root2leaf)
    # Python is complaining because the inner set objects are mutable 
    # and thus not hashable. The solution is to use frozenset 
    # for the inner sets, to indicate that you have no 
    # intention of modifying them: frozenset(root2leaf)

    # set comprehensions instead of FOR loop
    commands_set = {frozenset(root2leaf) for root2leaf, value in nested_keys(commands.COMMANDS)}
    # for root2leaf, value in nested_keys(commands.COMMANDS):
    #     commands_set.add(frozenset(root2leaf))
    help_set = {frozenset(root2leaf) for root2leaf, value in nested_keys(commands.HELP)}
    # for root2leaf, value in nested_keys(commands.HELP):
    #     commands_set.add(frozenset(root2leaf))
    
    # Sets Symmetric Difference
    # The resulting set has elements which are unique to each set. 
    # An element will be in the result set if either it is in the 
    # left-hand set and not in the right-hand set or it is in the 
    # right-hand set and not in the left-hand set.
    symetric_diff = commands_set ^ help_set
    if symetric_diff != set([]):
        print ''
        print ' The following command(s):'
        print ''
        print ' ' + commands.KEY_SEPARATOR.join(str(commands.KEY_SEPARATOR.join(command)) + '\n' for command in symetric_diff)
        print ' is/are missing either a description or a mapped command!'
        print ' Please review HELP and/or COMMANDS trees!'
        print ''
        sys.exit()

def main():
    # print 'Number of arguments:', len(sys.argv), 'arguments.'
    # print 'Argument List:', str(sys.argv)
    if 'help' in sys.argv:
        print ''
        print_nested_keys(commands.HELP)
        print ''
        sys.exit()

    # Remove /usr/local/bin/ from first argument (/usr/local/bin/nita)
    root = sys.argv[0].split('/')[-1]
    cli = sys.argv[1:]
    cli.insert(0, root)



    commands_vs_help()



    try:
        command = cli2command(cli, commands.COMMANDS)
        # If % vars in command
        if '%' in command:
                
            print ''
            print '  >>>> command: ', command % commands.PROJECT_PATH
            print ''
            os.system(command % commands.PROJECT_PATH)

        else:

            print ''
            print '  >>>> command: ', command
            print ''
            os.system(command)

    except KeyError as ke:
        print ''
        print('"' + ke.message + '" key does not exist at COMMANDS dictionary')
        print ''

if __name__ == '__main__':
    main()
